var tipuesearch = {"pages":[{"title":" easy ","text":"easy Fortran rationals About A package that implements rationals number as a numeric type, useful for lossless computations. Arithmetic procedures are all pure and elemental. Use Here is an overview, see test and example code for all available uses ! Declarae type type ( rational ) :: a , b , c ! Set value via constructor a = rational ( 2 , 3 ) ! fraction 2/3 b = rational ( 2 ) ! integer 2 c = rational ( \"3/4\" ) ! fraction 3/4 ! Set value via assignment a = 2 ! integer 2 ! Write a value write ( * , * ) rational ( 4 , 5 ) ! Check if rational is an integer write ( * , \"(L1)\" ) a % is_integer () ! Do conditional and arithmetic if ( rational ( 5 , 8 ) < rational ( 8 , 13 )) then write ( * , * ) rational ( 8 , 13 ) - rational ( 5 , 8 ) else write ( * , * ) ( rational ( 8 , 13 ) + rational ( 5 , 8 )) / 21 end if Developer Info John Doe","tags":"home","url":"index.html"},{"title":"rational – easy ","text":"type, public :: rational Constructor public        interface rational private pure elemental function rat_real_const(r) result(rat) Construct rational from real Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value type( rational ) private pure elemental function rat_char_const(str) result(r) Construct rational from character Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value type( rational ) private pure elemental function rat_int_const(n) result(rat) Construct rational from integer Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: n Return Value type( rational ) private pure elemental function rat_const_ik(n, d) result(rat) Construct rational from numerator and denominator Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: n Numerator integer(kind=ik), intent(in) :: d Denominator Return Value type( rational ) private pure elemental function rat_const_ir(n, d) result(rat) Construct rational from numerator and denominator Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: n Numerator integer(kind=ir), intent(in) :: d Denominator Return Value type( rational ) Type-Bound Procedures procedure, public :: get_den private pure elemental function get_den(self) result(den) Get rational denominator Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self Return Value integer(kind=ir) procedure, public :: get_num private pure elemental function get_num(self) result(num) Get rational numerator Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self Return Value integer(kind=ir) procedure, public :: inverse private pure elemental function inverse(self) result(b) Reciprocal of rational Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self Return Value type( rational ) procedure, public :: is_integer private pure elemental function is_integer(self) result(res) Check if rational is integer Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self Return Value logical generic, public :: read(formatted) => read_formatted private  subroutine read_formatted(self, unit, iotype, v_list, iostat, iomsg) Read formatted rational Arguments Type Intent Optional Attributes Name class( rational ), intent(inout) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: read_formatted private  subroutine read_formatted(self, unit, iotype, v_list, iostat, iomsg) Read formatted rational Arguments Type Intent Optional Attributes Name class( rational ), intent(inout) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: simplify private pure elemental subroutine simplify(a) Simplify the fraction of a rational Arguments Type Intent Optional Attributes Name class( rational ), intent(inout) :: a generic, public :: write(formatted) => write_formatted private  subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Write formatted rational Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg procedure, public :: write_formatted private  subroutine write_formatted(self, unit, iotype, v_list, iostat, iomsg) Write formatted rational Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Source Code type :: rational private integer ( ir ) :: num = 0 !! Numerator integer ( ir ) :: den = 1 !! Denominator logical :: o !! Dummy to offset default constructor interface contains procedure :: simplify procedure :: get_num , get_den procedure :: is_integer procedure :: inverse procedure :: write_formatted generic :: write ( formatted ) => write_formatted procedure :: read_formatted generic :: read ( formatted ) => read_formatted end type rational","tags":"","url":"type/rational.html"},{"title":"set_order – easy","text":"public  subroutine set_order(ord) Set order for random number generation Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: ord Source Code subroutine set_order ( ord ) !! Set order for random number generation integer ( ik ), intent ( in ) :: ord order = ord end subroutine set_order","tags":"","url":"proc/set_order.html"},{"title":"abs – easy","text":"public interface abs Module Procedures private pure elemental function rat_abs(b) result(a) Absolute value Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/abs.html"},{"title":"assignment(=) – easy","text":"public interface assignment(=) Module Procedures private pure elemental subroutine rat_set_rat(self, b) Set rational = rational Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: self type( rational ), intent(in) :: b private pure elemental subroutine rat_set_int(self, b) Set rational = Int Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: self integer(kind=ik), intent(in) :: b private pure elemental subroutine rat_set_real(self, b) Set rational = Real Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: self real(kind=rk), intent(in) :: b","tags":"","url":"interface/assignment(=).html"},{"title":"char – easy","text":"public interface char Module Procedures private pure elemental function rat_str(self) result(str) Convert rational to character Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self Return Value character(len=41)","tags":"","url":"interface/char.html"},{"title":"dot_product – easy","text":"public interface dot_product Module Procedures private pure function rat_dot(a, b) result(c) Dot product of two rational vectors Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:) type( rational ), intent(in) :: b (:) Return Value type( rational )","tags":"","url":"interface/dot_product.html"},{"title":"gcf – easy","text":"public interface gcf Module Procedures private pure elemental function gcf_ir(a, b) result(c) Calculate the greatest common factor of two integers Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: a integer(kind=ir), intent(in) :: b Return Value integer(kind=ir) private pure elemental function gcf_ik(a, b) result(c) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value integer(kind=ik) private pure elemental function gcf_rat(a, b) result(c) Calculate the greatest common factor of two rationals Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/gcf.html"},{"title":"int – easy","text":"public interface int Module Procedures private pure elemental function rat_int(b) result(i) Convert rational to integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value integer(kind=ik)","tags":"","url":"interface/int.html"},{"title":"lcm – easy","text":"public interface lcm Module Procedures private pure elemental function lcm_ir(a, b) result(c) Calculate the least common multiple of two integers Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: a integer(kind=ir), intent(in) :: b Return Value integer(kind=ir) private pure elemental function lcm_ik(a, b) result(c) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value integer(kind=ik)","tags":"","url":"interface/lcm.html"},{"title":"matmul – easy","text":"public interface matmul Module Procedures private pure function rat_matmul(a, b) result(c) Matrix multiply two rational arrays Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:,:) type( rational ), intent(in) :: b (:,:) Return Value type( rational ), (size(a,1),size(b,2)) private pure function rat_matvec(a, b) result(c) Matrix multiply a rational matrix with a rational vector Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:,:) type( rational ), intent(in) :: b (:) Return Value type( rational ), (size(b))","tags":"","url":"interface/matmul.html"},{"title":"max – easy","text":"public interface max Module Procedures private pure elemental function rat_max(a, b) result(c) Maximum rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/max.html"},{"title":"min – easy","text":"public interface min Module Procedures private pure elemental function rat_min(a, b) result(c) Minimum rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/min.html"},{"title":"operator(*) – easy","text":"public interface operator(*) Module Procedures private pure elemental function rat_mul_rat(a, b) result(c) Multiply two rationals safely Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_mul_int(a, b) result(c) Multiply rational and integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_mul_rat(a, b) result(c) Multiple integer and rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/operator(ASTERISK).html"},{"title":"operator(**) – easy","text":"public interface operator(**) Module Procedures private pure function rat_power_int(a, b) result(c) Raise rational to integer power Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/operator(ASTERISKASTERISK).html"},{"title":"operator(+) – easy","text":"public interface operator(+) Module Procedures private pure elemental function rat_add_rat(a, b) result(c) Add two rationals Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_add_int(a, b) result(c) Add rational and integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_add_rat(a, b) result(c) Add integer and rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function unary_plus(self) result(r) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: self Return Value type( rational )","tags":"","url":"interface/operator(+).html"},{"title":"operator(-) – easy","text":"public interface operator(-) Module Procedures private pure elemental function rat_sub_rat(a, b) result(c) Subtract two rationals Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_sub_int(a, b) result(c) Subtract integer from rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_sub_rat(a, b) result(c) Subtract rational from integer Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function negate(b) result(n) Negate rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/operator(-).html"},{"title":"operator(/) – easy","text":"public interface operator(/) Module Procedures private pure elemental function rat_div_rat(a, b) result(c) Divide two rationals safely Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_div_int(a, b) result(c) Divide rational by integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_div_rat(a, b) result(c) Divide integer by rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational )","tags":"","url":"interface/operator(SLASH).html"},{"title":"operator(/=) – easy","text":"public interface operator(/=) Module Procedures private pure elemental function rat_ne_rat(a, b) result(c) Check rational != rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_ne_int(a, b) result(c) Check rational != Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_ne_rat(a, b) result(c) Check Int != rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) – easy","text":"public interface operator(<) Module Procedures private pure elemental function rat_lt_rat(a, b) result(c) Check rational < rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_lt_int(a, b) result(c) Check rational < Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_lt_rat(a, b) result(c) Check Int < rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) – easy","text":"public interface operator(<=) Module Procedures private pure elemental function rat_le_rat(a, b) result(c) Check rational <= rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_le_int(a, b) result(c) Check rational <= Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_le_rat(a, b) result(c) Check Int <= rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(==) – easy","text":"public interface operator(==) Module Procedures private pure elemental function rat_eq_rat(a, b) result(c) Check rational == rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_eq_int(a, b) result(c) Check rational == Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_eq_rat(a, b) result(c) Check Int == rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"operator(>) – easy","text":"public interface operator(>) Module Procedures private pure elemental function rat_gt_rat(a, b) result(c) Check rational > rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_gt_int(a, b) result(c) Check rational > Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_gt_rat(a, b) result(c) Check Int > rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) – easy","text":"public interface operator(>=) Module Procedures private pure elemental function rat_ge_rat(a, b) result(c) Check rational >= rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_ge_int(a, b) result(c) Check rational >= Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_ge_rat(a, b) result(c) Check Int >= rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical","tags":"","url":"interface/operator(gt=).html"},{"title":"random_number – easy","text":"public interface random_number Module Procedures private impure elemental subroutine rat_rand(a) Retrieve random rational (0.0, order) Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: a","tags":"","url":"interface/random_number.html"},{"title":"rational – easy","text":"public interface rational Module Procedures private pure elemental function rat_real_const(r) result(rat) Construct rational from real Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value type( rational ) private pure elemental function rat_char_const(str) result(r) Construct rational from character Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value type( rational ) private pure elemental function rat_int_const(n) result(rat) Construct rational from integer Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: n Return Value type( rational ) private pure elemental function rat_const_ik(n, d) result(rat) Construct rational from numerator and denominator Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: n Numerator integer(kind=ik), intent(in) :: d Denominator Return Value type( rational ) private pure elemental function rat_const_ir(n, d) result(rat) Construct rational from numerator and denominator Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: n Numerator integer(kind=ir), intent(in) :: d Denominator Return Value type( rational )","tags":"","url":"interface/rational.html"},{"title":"real – easy","text":"public interface real Module Procedures private pure elemental function rat_real(b) result(r) Convert rational to real Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value real(kind=rk)","tags":"","url":"interface/real.html"},{"title":"transpose – easy","text":"public interface transpose Module Procedures private pure function rat_transpose(a) result(b) Transpose rational matrix Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:,:) Return Value type( rational ), (size(a,2),size(a,1))","tags":"","url":"interface/transpose.html"},{"title":"ex1 – easy","text":"subroutine ex1() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i real(kind=rk), public, parameter :: pi = 4*atan(1.0_rk) type( rational ), public :: rat_pi Source Code subroutine ex1 () integer :: i real ( rk ), parameter :: pi = 4 * atan ( 1.0_rk ) type ( rational ) :: rat_pi write ( * , \"(A)\" ) \"Example: rational representation of pi\" rat_pi = pi write ( * , * ) pi write ( * , * ) rat_pi do i = 1 , 8 write ( * , * ) rational ( int ( pi * 10 ** i ), 10 ** i ) end do ! i write ( * , * ) end subroutine ex1","tags":"","url":"proc/ex1.html"},{"title":"ex2 – easy","text":"subroutine ex2() Arguments None Variables Type Visibility Attributes Name Initial integer, public :: i type( rational ), public :: roottwo Source Code subroutine ex2 () integer :: i type ( rational ) :: roottwo write ( * , \"(A)\" ) \"Example: approximation of the square root of two\" roottwo = 1 do i = 1 , 10 roottwo = 1 + 1 / ( 1 + roottwo ) write ( * , \"(I3,')',1x,$)\" ) i write ( * , * ) roottwo , real ( roottwo ), real ( roottwo * roottwo ) end do ! i end subroutine ex2","tags":"","url":"proc/ex2.html"},{"title":"rationals – easy","text":"rational numbers @note Todo\n     mod, divmod, floor, ceil, trunc, round, sign\n     is_integer, compare\n     inverse * * * I / O * * * * * * * * * C O N S T R U C T O R S * * * *** * * * C A S T I N G * * * * * * * * * A S S I G N M E N T * * * * * * * A D D I T I O N * * * * **** * * * S U B T R A C T I O N * * * * * * * M U L T I P L I C A T I O N * * * * * * * D I V I S I O N * * * * **** * * * E X P O N E N T I A T I O N * * * * * * * E Q U A L I T Y * * * * **** * * * I N E Q U A L I T Y * * * * * * * S U P E R I O R I T Y * * * * * * * I N F E R I O R I T Y * * * * * * * S U P E R I O R I T Y * * * * * * * I N F E R I O R I T Y * * * * * * * U T I L I T Y * * * * * * * * * I N T R I N S I C  F U N C T I O N S * **** * * * F U N C T I O N S * * * * ** * * * E N D * * * * * * Uses iso_fortran_env Interfaces public        interface abs private pure elemental function rat_abs(b) result(a) Absolute value Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value type( rational ) public        interface assignment(=) private pure elemental subroutine rat_set_rat(self, b) Set rational = rational Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: self type( rational ), intent(in) :: b private pure elemental subroutine rat_set_int(self, b) Set rational = Int Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: self integer(kind=ik), intent(in) :: b private pure elemental subroutine rat_set_real(self, b) Set rational = Real Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: self real(kind=rk), intent(in) :: b public        interface char private pure elemental function rat_str(self) result(str) Convert rational to character Arguments Type Intent Optional Attributes Name class( rational ), intent(in) :: self Return Value character(len=41) public        interface dot_product private pure function rat_dot(a, b) result(c) Dot product of two rational vectors Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:) type( rational ), intent(in) :: b (:) Return Value type( rational ) public        interface gcf private pure elemental function gcf_ir(a, b) result(c) Calculate the greatest common factor of two integers Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: a integer(kind=ir), intent(in) :: b Return Value integer(kind=ir) private pure elemental function gcf_ik(a, b) result(c) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value integer(kind=ik) private pure elemental function gcf_rat(a, b) result(c) Calculate the greatest common factor of two rationals Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) public        interface int private pure elemental function rat_int(b) result(i) Convert rational to integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value integer(kind=ik) public        interface lcm private pure elemental function lcm_ir(a, b) result(c) Calculate the least common multiple of two integers Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: a integer(kind=ir), intent(in) :: b Return Value integer(kind=ir) private pure elemental function lcm_ik(a, b) result(c) Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value integer(kind=ik) public        interface matmul private pure function rat_matmul(a, b) result(c) Matrix multiply two rational arrays Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:,:) type( rational ), intent(in) :: b (:,:) Return Value type( rational ), (size(a,1),size(b,2)) private pure function rat_matvec(a, b) result(c) Matrix multiply a rational matrix with a rational vector Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:,:) type( rational ), intent(in) :: b (:) Return Value type( rational ), (size(b)) public        interface max private pure elemental function rat_max(a, b) result(c) Maximum rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) public        interface min private pure elemental function rat_min(a, b) result(c) Minimum rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) public        interface operator(*) private pure elemental function rat_mul_rat(a, b) result(c) Multiply two rationals safely Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_mul_int(a, b) result(c) Multiply rational and integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_mul_rat(a, b) result(c) Multiple integer and rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) public        interface operator(**) private pure function rat_power_int(a, b) result(c) Raise rational to integer power Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) public        interface operator(+) private pure elemental function rat_add_rat(a, b) result(c) Add two rationals Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_add_int(a, b) result(c) Add rational and integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_add_rat(a, b) result(c) Add integer and rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function unary_plus(self) result(r) Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: self Return Value type( rational ) public        interface operator(-) private pure elemental function rat_sub_rat(a, b) result(c) Subtract two rationals Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_sub_int(a, b) result(c) Subtract integer from rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_sub_rat(a, b) result(c) Subtract rational from integer Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function negate(b) result(n) Negate rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value type( rational ) public        interface operator(/) private pure elemental function rat_div_rat(a, b) result(c) Divide two rationals safely Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) private pure elemental function rat_div_int(a, b) result(c) Divide rational by integer Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value type( rational ) private pure elemental function int_div_rat(a, b) result(c) Divide integer by rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value type( rational ) public        interface operator(/=) private pure elemental function rat_ne_rat(a, b) result(c) Check rational != rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_ne_int(a, b) result(c) Check rational != Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_ne_rat(a, b) result(c) Check Int != rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical public        interface operator(<) private pure elemental function rat_lt_rat(a, b) result(c) Check rational < rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_lt_int(a, b) result(c) Check rational < Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_lt_rat(a, b) result(c) Check Int < rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical public        interface operator(<=) private pure elemental function rat_le_rat(a, b) result(c) Check rational <= rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_le_int(a, b) result(c) Check rational <= Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_le_rat(a, b) result(c) Check Int <= rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical public        interface operator(==) private pure elemental function rat_eq_rat(a, b) result(c) Check rational == rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_eq_int(a, b) result(c) Check rational == Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_eq_rat(a, b) result(c) Check Int == rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical public        interface operator(>) private pure elemental function rat_gt_rat(a, b) result(c) Check rational > rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_gt_int(a, b) result(c) Check rational > Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_gt_rat(a, b) result(c) Check Int > rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical public        interface operator(>=) private pure elemental function rat_ge_rat(a, b) result(c) Check rational >= rational Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a type( rational ), intent(in) :: b Return Value logical private pure elemental function rat_ge_int(a, b) result(c) Check rational >= Int Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a integer(kind=ik), intent(in) :: b Return Value logical private pure elemental function int_ge_rat(a, b) result(c) Check Int >= rational Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: a type( rational ), intent(in) :: b Return Value logical public        interface random_number private impure elemental subroutine rat_rand(a) Retrieve random rational (0.0, order) Arguments Type Intent Optional Attributes Name type( rational ), intent(out) :: a public        interface rational private pure elemental function rat_real_const(r) result(rat) Construct rational from real Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in) :: r Return Value type( rational ) private pure elemental function rat_char_const(str) result(r) Construct rational from character Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value type( rational ) private pure elemental function rat_int_const(n) result(rat) Construct rational from integer Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: n Return Value type( rational ) private pure elemental function rat_const_ik(n, d) result(rat) Construct rational from numerator and denominator Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: n Numerator integer(kind=ik), intent(in) :: d Denominator Return Value type( rational ) private pure elemental function rat_const_ir(n, d) result(rat) Construct rational from numerator and denominator Arguments Type Intent Optional Attributes Name integer(kind=ir), intent(in) :: n Numerator integer(kind=ir), intent(in) :: d Denominator Return Value type( rational ) public        interface real private pure elemental function rat_real(b) result(r) Convert rational to real Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: b Return Value real(kind=rk) public        interface transpose private pure function rat_transpose(a) result(b) Transpose rational matrix Arguments Type Intent Optional Attributes Name type( rational ), intent(in) :: a (:,:) Return Value type( rational ), (size(a,2),size(a,1)) Derived Types type, public :: rational Constructor private\n\n                    pure, elemental\n                    function rat_real_const (r) Construct rational from real private\n\n                    pure, elemental\n                    function rat_char_const (str) Construct rational from character private\n\n                    pure, elemental\n                    function rat_int_const (n) Construct rational from integer private\n\n                    pure, elemental\n                    function rat_const_ik (n, d) Construct rational from numerator and denominator private\n\n                    pure, elemental\n                    function rat_const_ir (n, d) Construct rational from numerator and denominator Type-Bound Procedures procedure, public :: get_den procedure, public :: get_num procedure, public :: inverse procedure, public :: is_integer generic, public :: read(formatted) => read_formatted procedure, public :: read_formatted procedure, public :: simplify generic, public :: write(formatted) => write_formatted procedure, public :: write_formatted Subroutines public  subroutine set_order (ord) Set order for random number generation Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: ord","tags":"","url":"module/rationals.html"},{"title":"example – easy","text":"Uses rationals Subroutines subroutine ex1 () Arguments None subroutine ex2 () Arguments None Source Code program example use rationals implicit none call ex1 () call ex2 () contains subroutine ex1 () integer :: i real ( rk ), parameter :: pi = 4 * atan ( 1.0_rk ) type ( rational ) :: rat_pi write ( * , \"(A)\" ) \"Example: rational representation of pi\" rat_pi = pi write ( * , * ) pi write ( * , * ) rat_pi do i = 1 , 8 write ( * , * ) rational ( int ( pi * 10 ** i ), 10 ** i ) end do ! i write ( * , * ) end subroutine ex1 !*********************************************************************** subroutine ex2 () integer :: i type ( rational ) :: roottwo write ( * , \"(A)\" ) \"Example: approximation of the square root of two\" roottwo = 1 do i = 1 , 10 roottwo = 1 + 1 / ( 1 + roottwo ) write ( * , \"(I3,')',1x,$)\" ) i write ( * , * ) roottwo , real ( roottwo ), real ( roottwo * roottwo ) end do ! i end subroutine ex2 end program example","tags":"","url":"program/example.html"},{"title":"rationals_test – easy","text":"Uses rationals iso_fortran_env Showcase rationals Variables Type Attributes Name Initial type( rational ) :: a type( rational ) :: b character(len=*), parameter :: fmt1 = \"(A20,': ',$)\" character(len=*), parameter :: fmt2 = \"('passed')\" type( rational ) :: m (2,2) type( rational ) :: n (2,2) integer(kind=ik) :: ord type( rational ) :: p (2,2) integer :: stat character(len=50) :: str type( rational ) :: u (2) integer :: unit type( rational ) :: v (2) integer(kind=ir), parameter :: yoog = huge(1_ir) Source Code program rationals_test !! Showcase rationals use iso_fortran_env use rationals implicit none integer ( ir ), parameter :: yoog = huge ( 1_ir ) integer ( ik ) :: ord integer :: unit integer :: stat character ( * ), parameter :: fmt1 = \"(A20,': ',$)\" character ( * ), parameter :: fmt2 = \"('passed')\" character ( 50 ) :: str type ( rational ) :: a , b type ( rational ) :: u ( 2 ), v ( 2 ), m ( 2 , 2 ), n ( 2 , 2 ), p ( 2 , 2 ) str = \"1/2  \" write ( * , \"(A)\" ) \"--- Testing rationals ---\" write ( * , \"(A)\" ) \"Basics\" write ( * , fmt1 ) \"Math\" if ( gcf ( 0 , 2 ) /= 0 ) then error stop \"gcf failed for 0\" end if if ( gcf ( 2 , 3 ) /= 1 ) then error stop \"gcf failed for coprime\" end if if ( gcf ( 12 , 12 ) /= 12 ) then error stop \"gcf failed for equality\" end if if ( gcf ( 3 , 12 ) /= 3 ) then error stop \"gcf failed for result\" end if if ( gcf ( - 3 , 12 ) /= 3 ) then error stop \"gcf failed for negative input\" end if if ( lcm ( 0 , 1 ) /= 0 ) then error stop \"lcm failed for zero\" end if if ( lcm ( 3 , 3 ) /= 3 ) then error stop \"lcm failed for equality\" end if if ( lcm ( 2 , 3 ) /= 6 ) then error stop \"lcm failed for product result\" end if if ( lcm ( 4 , 6 ) /= 12 ) then error stop \"lcm failed for non-product result\" end if if ( lcm ( - 4 , 6 ) /= 12 ) then error stop \"lcm failed for negative\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Constructor\" ! a = rational(1, 1) ! if ((a%get_num() /= 1) .or. (a%get_den() /= 1)) then !   error stop \"Default constructor failed\" ! end if a = rational ( 3 ) if (( a % get_num () /= 3 ) . or . ( a % get_den () /= 1 )) then error stop \"Integer constructor failed\" end if a = rational ( 0.5_rk ) if (( a % get_num () /= 1 ) . or . ( a % get_den () /= 2 )) then error stop \"Real constructor failed\" end if a = rational ( \"1/2\" ) if (( a % get_num () /= 1 ) . or . ( a % get_den () /= 2 )) then error stop \"Character constructor failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"I/O\" read ( str , \"(A)\" , iostat = stat ) a if ( stat /= 0 ) then error stop \"Formatted read failed\" end if open ( newunit = unit , file = \"scratch\" , action = 'write' ) write ( unit , * ) a close ( unit , status = 'delete' ) write ( * , fmt2 ) write ( * , fmt1 ) \"Assignment\" a = 2 if (( a % get_num () /= 2 ) . or . ( a % get_den () /= 1 )) then error stop \"Integer assignment failed\" end if a = 0.5_rk if (( a % get_num () /= 1 ) . or . ( a % get_den () /= 2 )) then error stop \"Real assignment failed\" end if ! a = \"1/2\"   !! Not supported by Fortran b = a if (( b % get_num () /= a % get_num ()) . or . ( b % get_den () /= a % get_den ())) then error stop \"Copying failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Casting\" a = 2 if ( int ( a ) /= 2 ) then error stop \"Casting to integer failed\" end if a = 0.5_rk if ( real ( a ) /= 0.5_rk ) then error stop \"Casting to real failed\" end if if ( char ( a ) /= \"1/2\" ) then error stop \"Casting to character failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"Boolean operators\" write ( * , fmt1 ) \"Equality\" a = 2 b = 2 if (. not .( a == b )) then error stop \"Rational-rational equality failed\" end if if (. not .( a == 2 )) then error stop \"Rational-integer equality failed\" end if if (. not .( 2 == a )) then error stop \"Integer-rational equality failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Inequality\" a = 2 b = 3 if (. not .( a /= b )) then error stop \"Rational-rational inequality failed\" end if if (. not .( a /= 3 )) then error stop \"Rational-integer inequality failed\" end if if (. not .( 3 /= a )) then error stop \"Integer-rational inequality failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Strict superiority\" a = rational ( 3 , 2 ) b = rational ( 2 , 3 ) if (. not .( a > b )) then error stop \"Rational-rational strict superiority failed\" end if if (. not .( a > 1 )) then error stop \"Rational-integer strict superiority failed\" end if if (. not .( 2 > a )) then error stop \"Integer-rational strict superiority failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Strict inferiority\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if (. not .( a < b )) then error stop \"Rational-rational strict inferiority failed\" end if if (. not .( a < 1 )) then error stop \"Rational-integer strict inferiority failed\" end if if (. not .( 0 < a )) then error stop \"Integer-rational strict inferiority failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Superiority\" a = rational ( 3 , 2 ) b = rational ( 2 , 3 ) if (. not .( a >= b )) then error stop \"Rational-rational superiority failed\" end if if (. not .( a >= 1 )) then error stop \"Rational-integer superiority failed\" end if if (. not .( 2 >= a )) then error stop \"Integer-rational superiority failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Inferiority\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if (. not .( a <= b )) then error stop \"Rational-rational inferiority failed\" end if if (. not .( a <= 1 )) then error stop \"Rational-integer inferiority failed\" end if if (. not .( 0 <= a )) then error stop \"Integer-rational inferiority failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"Arithmetic\" write ( * , fmt1 ) \"Addition\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a + b /= rational ( 13 , 6 )) then error stop \"Rational-rational addition failed\" end if if ( a + 1 /= rational ( 5 , 3 )) then error stop \"Rational-integer addition failed\" end if if ( 1 + a /= rational ( 5 , 3 )) then error stop \"Integer-rational addition failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Subtraction\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a - b /= rational ( - 5 , 6 )) then error stop \"Rational-rational subtraction failed\" end if if ( a - 1 /= rational ( - 1 , 3 )) then error stop \"Rational-integer subtraction failed\" end if if ( 1 - a /= rational ( 1 , 3 )) then error stop \"Integer-rational subtraction failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Multiplication\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a * b /= rational ( 1 , 1 )) then error stop \"Rational-rational multiplication failed\" end if if ( a * 2 /= rational ( 4 , 3 )) then error stop \"Rational-integer multiplication failed\" end if if ( 2 * a /= rational ( 4 , 3 )) then error stop \"Integer-rational multiplication failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Division\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a / b /= rational ( 4 , 9 )) then error stop \"Rational-rational division failed\" end if if ( a / 2 /= rational ( 1 , 3 )) then error stop \"Rational-integer division failed\" end if if ( 2 / a /= rational ( 3 , 1 )) then error stop \"Integer-rational division failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Reciprocal\" a = rational ( 2 , 3 ) if ( a % inverse () /= 1 / a ) then error stop \"Reciprocation failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Exponentiation\" a = rational ( 2 , 3 ) if ( a ** 2 /= rational ( 4 , 9 )) then error stop \"Rational-integer exponentiation failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Edge cases\" a = rational ( yoog , 2_ir ) b = rational ( 2_ir , yoog ) if ( a * b /= 1 ) then error stop \"Multiplication overflow failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"Functions\" write ( * , fmt1 ) \"abs\" a = rational ( - 1 , 2 ) if ( abs ( a ) /= rational ( 1 , 2 )) then error stop \"Absolute value failed\" end if a = rational ( 1 , 2 ) if ( abs ( a ) /= rational ( 1 , 2 )) then error stop \"Absolute value failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"min\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( min ( a , b ) /= a ) then error stop \"Rational-rational minimum failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"max\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( max ( a , b ) /= b ) then error stop \"Rational-rational maximum failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"dot_product\" u = [ rational ( 1 , 2 ), rational ( 2 , 3 )] v = [ rational ( 3 , 4 ), rational ( 4 , 5 )] if ( dot_product ( u , v ) /= rational ( 109 , 120 )) then error stop \"dot_product failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"matmul\" m (:, 1 ) = [ rational ( 1 , 2 ), rational ( 1 , 3 )] m (:, 2 ) = [ rational ( 1 , 1 ), rational ( 2 , 3 )] u = [ rational ( 1 , 4 ), rational ( 3 , 4 )] v = [ rational ( 7 , 8 ), rational ( 7 , 12 )] if (. not . all ( matmul ( m , u ) == v )) then error stop \"matmul for matrix-vector failed\" end if n (:, 1 ) = [ rational ( 1 , 4 ), rational ( 3 , 4 )] n (:, 2 ) = [ rational ( 1 , 2 ), rational ( 1 , 1 )] p (:, 1 ) = [ rational ( 7 , 8 ), rational ( 7 , 12 )] p (:, 2 ) = [ rational ( 5 , 4 ), rational ( 5 , 6 )] if (. not . all ( matmul ( m , n ) == p )) then error stop \"matmul for matrix-matrix failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"transpose\" m (:, 1 ) = [ rational ( 1 , 2 ), rational ( 1 , 3 )] m (:, 2 ) = [ rational ( 1 , 1 ), rational ( 2 , 3 )] n (:, 1 ) = [ rational ( 1 , 2 ), rational ( 1 , 1 )] n (:, 2 ) = [ rational ( 1 , 3 ), rational ( 2 , 3 )] if (. not . all ( transpose ( m ) == n )) then error stop \"transpose failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"random_number\" ord = 10 call set_order ( ord ) call random_number ( m ) if ( any ( m < 0 ) . or . any ( m > ord )) then error stop \"random_number failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"All tests passed\" end program rationals_test","tags":"","url":"program/rationals_test.html"},{"title":"rationals.f90 – easy","text":"Source Code module rationals !! rational numbers !! @todo !! mod, divmod, floor, ceil, trunc, round, sign !! is_integer, compare !! inverse use iso_fortran_env , only : ir => int64 , ik => int32 , rk => real64 implicit none private public :: ir , ik , rk integer ( ik ), parameter :: primes ( * ) = & [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , & 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , 103 , 107 , 109 , 113 , 127 , 131 , & 137 , 139 , 149 , 151 , 157 , 163 , 167 , 173 , 179 , 181 , 191 , 193 , 197 , 199 , 211 , 223 , & 227 , 229 , 233 , 239 , 241 , 251 , 257 , 263 , 269 , 271 , 277 , 281 , 283 , 293 , 307 , 311 , & 313 , 317 , 331 , 337 , 347 , 349 , 353 , 359 , 367 , 373 , 379 , 383 , 389 , 397 , 401 , 409 , & 419 , 421 , 431 , 433 , 439 , 443 , 449 , 457 , 461 , 463 , 467 , 479 , 487 , 491 , 499 , 503 , & 509 , 521 , 523 , 541 , 547 , 557 , 563 , 569 , 571 , 577 , 587 , 593 , 599 , 601 , 607 , 613 , & 617 , 619 , 631 , 641 , 643 , 647 , 653 , 659 , 661 , 673 , 677 , 683 , 691 , 701 , 709 , 719 , & 727 , 733 , 739 , 743 , 751 , 757 , 761 , 769 , 773 , 787 , 797 , 809 , 811 , 821 , 823 , 827 , & 829 , 839 , 853 , 857 , 859 , 863 , 877 , 881 , 883 , 887 , 907 , 911 , 919 , 929 , 937 , 941 , & 947 , 953 , 967 , 971 , 977 , 983 , 991 , 997 ] integer ( ik ) :: order = 10 type :: rational private integer ( ir ) :: num = 0 !! Numerator integer ( ir ) :: den = 1 !! Denominator logical :: o !! Dummy to offset default constructor interface contains procedure :: simplify procedure :: get_num , get_den procedure :: is_integer procedure :: inverse procedure :: write_formatted generic :: write ( formatted ) => write_formatted procedure :: read_formatted generic :: read ( formatted ) => read_formatted end type rational ! Assignment interface assignment ( = ) procedure :: rat_set_rat , rat_set_int , rat_set_real end interface assignment ( = ) ! Addition interface operator ( + ) procedure :: rat_add_rat , rat_add_int , int_add_rat , unary_plus end interface operator ( + ) ! Subtraction interface operator ( - ) procedure :: rat_sub_rat , rat_sub_int , int_sub_rat , negate end interface operator ( - ) ! Multiplication interface operator ( * ) procedure :: rat_mul_rat , rat_mul_int , int_mul_rat end interface operator ( * ) ! Division interface operator ( / ) procedure :: rat_div_rat , rat_div_int , int_div_rat end interface operator ( / ) ! Exponentiation interface operator ( ** ) procedure :: rat_power_int end interface operator ( ** ) ! Check equality interface operator ( == ) procedure :: rat_eq_rat , rat_eq_int , int_eq_rat end interface operator ( == ) ! Check inequaly interface operator ( /= ) procedure :: rat_ne_rat , rat_ne_int , int_ne_rat end interface operator ( /= ) ! Check greater than interface operator ( > ) procedure :: rat_gt_rat , rat_gt_int , int_gt_rat end interface operator ( > ) ! Check less than interface operator ( < ) procedure :: rat_lt_rat , rat_lt_int , int_lt_rat end interface operator ( < ) ! Check greater than or equal interface operator ( >= ) procedure :: rat_ge_rat , rat_ge_int , int_ge_rat end interface operator ( >= ) ! Check less than or equal interface operator ( <= ) procedure :: rat_le_rat , rat_le_int , int_le_rat end interface operator ( <= ) interface rational module procedure :: rat_real_const , rat_char_const , rat_int_const module procedure :: rat_const_ik , rat_const_ir end interface rational interface char procedure :: rat_str end interface char interface int procedure :: rat_int end interface int interface real procedure :: rat_real end interface real interface gcf module procedure :: gcf_ir , gcf_ik , gcf_rat end interface gcf interface lcm module procedure :: lcm_ir , lcm_ik end interface lcm interface abs module procedure :: rat_abs end interface abs interface min module procedure :: rat_min end interface min interface max module procedure :: rat_max end interface max interface dot_product module procedure :: rat_dot end interface dot_product interface matmul module procedure :: rat_matmul module procedure :: rat_matvec end interface matmul interface transpose module procedure :: rat_transpose end interface transpose interface random_number module procedure :: rat_rand end interface random_number public :: rational public :: assignment ( = ) public :: operator ( + ), operator ( - ), operator ( * ), operator ( / ), operator ( ** ) public :: operator ( == ), operator ( /= ) public :: operator ( > ), operator ( < ), operator ( >= ), operator ( <= ) public :: char , int , real public :: set_order , lcm , gcf public :: random_number , abs , min , max , dot_product , matmul , transpose contains !*********************************************************************** pure elemental integer ( ir ) function get_num ( self ) result ( num ) !! Get rational numerator class ( rational ), intent ( in ) :: self num = self % num end function get_num !*********************************************************************** pure elemental integer ( ir ) function get_den ( self ) result ( den ) !! Get rational denominator class ( rational ), intent ( in ) :: self den = self % den end function get_den !*********************************************************************** pure elemental logical function is_integer ( self ) result ( res ) !! Check if rational is integer class ( rational ), intent ( in ) :: self res = self % den == 1 end function is_integer !*********************************************************************** !******************* I / O ********************************************* !*********************************************************************** subroutine write_formatted ( self , unit , iotype , v_list , iostat , iomsg ) !! Write formatted rational class ( rational ), intent ( in ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg if (( len_trim ( iotype ) >= 0 ) . and . ( size ( v_list ) >= 0 )) continue write ( unit , \"(I0)\" , advance = 'no' , iostat = iostat , iomsg = iomsg ) self % num write ( unit , \"('/')\" , advance = 'no' , iostat = iostat , iomsg = iomsg ) write ( unit , \"(I0)\" , iostat = iostat , iomsg = iomsg ) self % den end subroutine write_formatted !*********************************************************************** subroutine read_formatted ( self , unit , iotype , v_list , iostat , iomsg ) !! Read formatted rational class ( rational ), intent ( inout ) :: self integer , intent ( in ) :: unit character ( * ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( * ), intent ( inout ) :: iomsg character ( 50 ) :: line if (( len_trim ( iotype ) >= 0 ) . and . ( size ( v_list ) >= 0 )) continue read ( unit , \"(A50)\" , iostat = iostat , iomsg = iomsg ) line self = rat_char_const ( line ) end subroutine read_formatted !*********************************************************************** !******************* C O N S T R U C T O R S *************************** !*********************************************************************** pure elemental type ( rational ) function rat_const_ik ( n , d ) result ( rat ) !! Construct rational from numerator and denominator integer ( ik ), intent ( in ) :: n !! Numerator integer ( ik ), intent ( in ) :: d !! Denominator rat % num = n rat % den = d call simplify ( rat ) end function rat_const_ik !*********************************************************************** pure elemental type ( rational ) function rat_const_ir ( n , d ) result ( rat ) !! Construct rational from numerator and denominator integer ( ir ), intent ( in ) :: n !! Numerator integer ( ir ), intent ( in ) :: d !! Denominator rat % num = n rat % den = d call simplify ( rat ) end function rat_const_ir !*********************************************************************** pure elemental type ( rational ) function rat_int_const ( n ) result ( rat ) !! Construct rational from integer integer ( ik ), intent ( in ) :: n rat % num = n rat % den = 1 end function rat_int_const !*********************************************************************** pure elemental type ( rational ) function rat_real_const ( r ) result ( rat ) !! Construct rational from real real ( rk ), intent ( in ) :: r rat % num = nint ( r * ( 10_ir ** 16 ), ir ) rat % den = 10_ir ** 16 call simplify ( rat ) end function rat_real_const !*********************************************************************** pure elemental type ( rational ) function rat_char_const ( str ) result ( r ) !! Construct rational from character character ( * ), intent ( in ) :: str integer ( ik ) :: i integer ( ik ) :: slash real ( rk ) :: f slash = index ( str , \"/\" ) if ( slash == 0 ) then if ( index ( str , \".\" ) /= 0 ) then read ( str , * ) f r = rat_real_const ( f ) else read ( str , * ) i r = rat_int_const ( i ) end if else read ( str ( 1 : slash - 1 ), * ) r % num read ( str ( slash + 1 :), * ) r % den end if call simplify ( r ) end function rat_char_const !*********************************************************************** !******************* C A S T I N G ************************************* !*********************************************************************** pure elemental character ( 41 ) function rat_str ( self ) result ( str ) !! Convert rational to character class ( rational ), intent ( in ) :: self character ( 20 ) :: n1 , n2 write ( n1 , \"(I20)\" ) self % num if ( self % den == 1 ) then str = trim ( adjustl ( n1 )) else if ( self % den == 0 ) then if ( self % num > 0 ) then str = \"Inf\" else if ( self % num < 0 ) then str = \"-Inf\" else str = \"NaN\" end if else write ( n2 , \"(I20)\" ) self % den str = trim ( adjustl ( n1 )) // \"/\" // trim ( adjustl ( n2 )) end if end function rat_str !*********************************************************************** pure elemental integer ( ik ) function rat_int ( b ) result ( i ) !! Convert rational to integer type ( rational ), intent ( in ) :: b i = nint (( 1.0_rk * b % num ) / b % den , ik ) end function rat_int !*********************************************************************** pure elemental real ( rk ) function rat_real ( b ) result ( r ) !! Convert rational to real type ( rational ), intent ( in ) :: b r = real ( b % num , rk ) / b % den end function rat_real !*********************************************************************** !******************* A S S I G N M E N T ******************************* !*********************************************************************** pure elemental subroutine rat_set_rat ( self , b ) !! Set rational = rational type ( rational ), intent ( out ) :: self type ( rational ), intent ( in ) :: b self % num = b % num self % den = b % den end subroutine rat_set_rat !*********************************************************************** pure elemental subroutine rat_set_int ( self , b ) !! Set rational = Int type ( rational ), intent ( out ) :: self integer ( ik ), intent ( in ) :: b self % num = b self % den = 1 end subroutine rat_set_int !*********************************************************************** pure elemental subroutine rat_set_real ( self , b ) !! Set rational = Real type ( rational ), intent ( out ) :: self real ( rk ), intent ( in ) :: b self % num = nint (( 10_ir ** 16 ) * b , ir ) self % den = 10_ir ** 16 call self % simplify () end subroutine rat_set_real !*********************************************************************** !******************* A D D I T I O N *********************************** !*********************************************************************** pure elemental type ( rational ) function rat_add_rat ( a , b ) result ( c ) !! Add two rationals type ( rational ), intent ( in ) :: a , b c % num = ( a % num ) * ( b % den ) + ( b % num ) * ( a % den ) c % den = ( a % den ) * ( b % den ) call c % simplify () end function rat_add_rat !*********************************************************************** pure elemental type ( rational ) function rat_add_int ( a , b ) result ( c ) !! Add rational and integer type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c % num = a % num + b * a % den c % den = a % den call c % simplify () end function rat_add_int !*********************************************************************** pure elemental type ( rational ) function int_add_rat ( a , b ) result ( c ) !! Add integer and rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c % num = b % num + a * b % den c % den = b % den call c % simplify () end function int_add_rat !*********************************************************************** pure elemental type ( Rational ) function unary_plus ( self ) result ( r ) type ( Rational ), intent ( in ) :: self r = self end function unary_plus !*********************************************************************** !******************* S U B T R A C T I O N ***************************** !*********************************************************************** pure elemental type ( rational ) function rat_sub_rat ( a , b ) result ( c ) !! Subtract two rationals type ( rational ), intent ( in ) :: a , b c % den = ( a % den ) * ( b % den ) c % num = ( a % num ) * ( b % den ) - ( b % num ) * ( a % den ) call c % simplify () end function rat_sub_rat !*********************************************************************** pure elemental type ( rational ) function rat_sub_int ( a , b ) result ( c ) !! Subtract integer from rational type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c % num = a % num - b * a % den c % den = a % den call c % simplify () end function rat_sub_int !*********************************************************************** pure elemental type ( rational ) function int_sub_rat ( a , b ) result ( c ) !! Subtract rational from integer integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c % num = a * b % den - b % num c % den = b % den call c % simplify () end function int_sub_rat !*********************************************************************** pure elemental type ( rational ) function negate ( b ) result ( n ) !! Negate rational type ( rational ), intent ( in ) :: b n % num = - b % num n % den = b % den end function negate !*********************************************************************** !******************* M U L T I P L I C A T I O N *********************** !*********************************************************************** pure elemental type ( rational ) function rat_mul_rat ( a , b ) result ( c ) !! Multiply two rationals safely type ( rational ), intent ( in ) :: a , b integer ( ir ) :: gcf1 , gcf2 integer ( ir ) :: hold1 , hold2 gcf1 = gcf_ir ( a % num , b % den ) gcf2 = gcf_ir ( a % den , b % num ) hold1 = a % num / gcf1 hold2 = b % num / gcf2 c % num = hold1 * hold2 hold1 = a % den / gcf2 hold2 = b % den / gcf1 c % den = hold1 * hold2 call c % simplify () end function rat_mul_rat !*********************************************************************** pure elemental type ( rational ) function rat_mul_int ( a , b ) result ( c ) !! Multiply rational and integer type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b integer ( ir ) :: gcf1 gcf1 = gcf_ir ( int ( b , ir ), a % den ) c % num = a % num * b / gcf1 c % den = a % den / gcf1 call c % simplify () end function rat_mul_int !*********************************************************************** pure elemental type ( rational ) function int_mul_rat ( a , b ) result ( c ) !! Multiple integer and rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b integer ( ir ) :: gcf1 gcf1 = gcf_ir ( int ( a , ir ), b % den ) c % num = b % num * a / gcf1 c % den = b % den / gcf1 call c % simplify () end function int_mul_rat !*********************************************************************** !******************* D I V I S I O N *********************************** !*********************************************************************** pure elemental type ( rational ) function rat_div_rat ( a , b ) result ( c ) !! Divide two rationals safely type ( rational ), intent ( in ) :: a , b integer ( ir ) :: gcf1 , gcf2 gcf1 = gcf_ir ( a % num , b % num ) gcf2 = gcf_ir ( a % den , b % den ) c % num = ( a % num / gcf1 ) * ( b % den / gcf2 ) c % den = ( a % den / gcf2 ) * ( b % num / gcf1 ) ! c%num = (a%num)*(b%den) ! c%den = (a%den)*(b%num) call c % simplify () end function rat_div_rat !*********************************************************************** pure elemental type ( rational ) function rat_div_int ( a , b ) result ( c ) !! Divide rational by integer type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b integer ( ir ) :: gcf1 gcf1 = gcf_ir ( int ( b , ir ), a % num ) c % num = a % num / gcf1 c % den = a % den * ( b / gcf1 ) call c % simplify () end function rat_div_int !*********************************************************************** pure elemental type ( rational ) function int_div_rat ( a , b ) result ( c ) !! Divide integer by rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b integer ( ir ) :: gcf1 gcf1 = gcf_ir ( int ( a , ir ), b % num ) c % num = b % den * ( a / gcf1 ) c % den = b % num / gcf1 call c % simplify () end function int_div_rat !*********************************************************************** !******************* E X P O N E N T I A T I O N *********************** !*********************************************************************** pure type ( rational ) function rat_power_int ( a , b ) result ( c ) !! Raise rational to integer power type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b integer ( ik ) :: i c % num = 1 c % den = 1 do i = 1 , b c % num = c % num * a % num c % den = c % den * a % den end do ! i end function rat_power_int !*********************************************************************** !******************* E Q U A L I T Y *********************************** !*********************************************************************** pure elemental logical function rat_eq_rat ( a , b ) result ( c ) !! Check rational == rational type ( rational ), intent ( in ) :: a , b c = ( a % num == b % num ). and .( a % den == b % den ) end function rat_eq_rat !*********************************************************************** pure elemental logical function rat_eq_int ( a , b ) result ( c ) !! Check rational == Int type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c = ( a % den == 1 ) . and . ( a % num == b ) end function rat_eq_int !*********************************************************************** pure elemental logical function int_eq_rat ( a , b ) result ( c ) !! Check Int == rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c = ( b % num == a ) end function int_eq_rat !*********************************************************************** !******************* I N E Q U A L I T Y ******************************* !*********************************************************************** pure elemental logical function rat_ne_rat ( a , b ) result ( c ) !! Check rational != rational type ( rational ), intent ( in ) :: a , b c = ( a % num /= b % num ) . or . ( a % den /= b % den ) end function rat_ne_rat !*********************************************************************** pure elemental logical function rat_ne_int ( a , b ) result ( c ) !! Check rational != Int type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c = ( a % num /= b ) . or . ( a % den /= 1 ) end function rat_ne_int !*********************************************************************** pure elemental logical function int_ne_rat ( a , b ) result ( c ) !! Check Int != rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c = ( b % num /= a ) . or . ( b % den /= 1 ) end function int_ne_rat !*********************************************************************** !******************* S U P E R I O R I T Y ***************************** !*********************************************************************** pure elemental logical function rat_gt_rat ( a , b ) result ( c ) !! Check rational > rational type ( rational ), intent ( in ) :: a , b c = ( a % num * b % den ) > ( b % num * a % den ) end function rat_gt_rat !*********************************************************************** pure elemental logical function rat_gt_int ( a , b ) result ( c ) !! Check rational > Int type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c = a % num > ( a % den * b ) end function rat_gt_int !*********************************************************************** pure elemental logical function int_gt_rat ( a , b ) result ( c ) !! Check Int > rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c = a * b % den > b % num end function int_gt_rat !*********************************************************************** !******************* I N F E R I O R I T Y ***************************** !*********************************************************************** pure elemental logical function rat_lt_rat ( a , b ) result ( c ) !! Check rational < rational type ( rational ), intent ( in ) :: a , b c = ( a % num * b % den ) < ( b % num * a % den ) end function rat_lt_rat !*********************************************************************** pure elemental logical function rat_lt_int ( a , b ) result ( c ) !! Check rational < Int type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c = a % num < ( a % den * b ) end function rat_lt_int !*********************************************************************** pure elemental logical function int_lt_rat ( a , b ) result ( c ) !! Check Int < rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c = a * b % den < b % num end function int_lt_rat !*********************************************************************** !******************* S U P E R I O R I T Y ***************************** !*********************************************************************** pure elemental logical function rat_ge_rat ( a , b ) result ( c ) !! Check rational >= rational type ( rational ), intent ( in ) :: a , b c = ( a % num * b % den ) >= ( b % num * a % den ) end function rat_ge_rat !*********************************************************************** pure elemental logical function rat_ge_int ( a , b ) result ( c ) !! Check rational >= Int type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c = a % num >= ( a % den * b ) end function rat_ge_int !*********************************************************************** pure elemental logical function int_ge_rat ( a , b ) result ( c ) !! Check Int >= rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c = a * b % den >= b % num end function int_ge_rat !*********************************************************************** !******************* I N F E R I O R I T Y ***************************** !*********************************************************************** pure elemental logical function rat_le_rat ( a , b ) result ( c ) !! Check rational <= rational type ( rational ), intent ( in ) :: a , b c = ( a % num * b % den ) <= ( b % num * a % den ) end function rat_le_rat !*********************************************************************** pure elemental logical function rat_le_int ( a , b ) result ( c ) !! Check rational <= Int type ( rational ), intent ( in ) :: a integer ( ik ), intent ( in ) :: b c = a % num <= ( a % den * b ) end function rat_le_int !*********************************************************************** pure elemental logical function int_le_rat ( a , b ) result ( c ) !! Check Int <= rational integer ( ik ), intent ( in ) :: a type ( rational ), intent ( in ) :: b c = a * b % den <= b % num end function int_le_rat !*********************************************************************** !******************* U T I L I T Y ************************************* !*********************************************************************** pure elemental subroutine simplify ( a ) !! Simplify the fraction of a rational class ( rational ), intent ( inout ) :: a integer ( ir ) :: fac if ( a % den == 0 ) then error stop \"rational%simplify: Division by zero\" end if if ( a % num == 0 ) then a % den = 1 return end if if ( a % den < 0 ) then a % num = - a % num a % den = - a % den end if fac = gcf_ir ( a % num , a % den ) a % num = a % num / fac a % den = a % den / fac if ( a % num == a % den ) then a % num = 1 a % den = 1 end if end subroutine simplify !*********************************************************************** pure elemental type ( rational ) function inverse ( self ) result ( b ) !! Reciprocal of rational class ( rational ), intent ( in ) :: self b % num = self % den b % den = self % num end function inverse !*********************************************************************** subroutine set_order ( ord ) !! Set order for random number generation integer ( ik ), intent ( in ) :: ord order = ord end subroutine set_order !*********************************************************************** !******************* I N T R I N S I C  F U N C T I O N S ************** !*********************************************************************** pure elemental type ( rational ) function rat_abs ( b ) result ( a ) !! Absolute value type ( rational ), intent ( in ) :: b a % num = abs ( b % num ) a % den = b % den end function rat_abs !*********************************************************************** pure elemental type ( rational ) function rat_min ( a , b ) result ( c ) !! Minimum rational type ( rational ), intent ( in ) :: a , b if ( a <= b ) then c = a else c = b end if end function rat_min !*********************************************************************** pure elemental type ( rational ) function rat_max ( a , b ) result ( c ) !! Maximum rational type ( rational ), intent ( in ) :: a , b if ( a >= b ) then c = a else c = b end if end function rat_max !*********************************************************************** pure type ( rational ) function rat_dot ( a , b ) result ( c ) !! Dot product of two rational vectors type ( rational ), intent ( in ) :: a (:), b (:) integer ( ik ) :: i if ( size ( a ) /= size ( b )) then error stop \"rational, dot: Incompatible vector sizes\" end if c = rational ( 0 , 1 ) do i = 1 , size ( a ) c = c + a ( i ) * b ( i ) end do ! i end function rat_dot !*********************************************************************** pure function rat_matmul ( a , b ) result ( c ) !! Matrix multiply two rational arrays type ( rational ), intent ( in ) :: a (:,:), b (:,:) type ( rational ) :: c ( size ( a , 1 ), size ( b , 2 )) integer :: i , j if ( size ( a , 2 ) /= size ( b , 1 )) then error stop \"rational, matmul: Incompatible matrix sizes\" end if do concurrent ( j = 1 : size ( b , 2 ), i = 1 : size ( a , 1 )) c ( i , j ) = rat_dot ( a ( i ,:), b (:, j )) end do ! j, i end function rat_matmul !*********************************************************************** pure function rat_matvec ( a , b ) result ( c ) !! Matrix multiply a rational matrix with a rational vector type ( rational ), intent ( in ) :: a (:,:), b (:) type ( rational ) :: c ( size ( b )) integer :: i if ( size ( a , 2 ) /= size ( b )) then error stop \"rational, matvec: Incompatible matrix sizes\" end if do i = 1 , size ( b ) c ( i ) = rat_dot ( a ( i ,:), b ) end do ! i end function rat_matvec !*********************************************************************** pure function rat_transpose ( a ) result ( b ) !! Transpose rational matrix type ( rational ), intent ( in ) :: a (:,:) type ( rational ) :: b ( size ( a , 2 ), size ( a , 1 )) integer :: i , j do i = 1 , size ( a , 1 ) do j = 1 , size ( a , 2 ) b ( j , i ) = a ( i , j ) end do ! j end do ! i end function rat_transpose !*********************************************************************** !******************* F U N C T I O N S ********************************* !*********************************************************************** pure elemental integer ( ir ) function lcm_ir ( a , b ) result ( c ) !! Calculate the least common multiple of two integers integer ( ir ), intent ( in ) :: a , b integer ( ir ) :: i integer ( ir ) :: prime integer ( ir ) :: p if (( a == 0 ). or .( b == 0 )) then c = 0 return end if c = 1 do i = 1 , size ( primes ) prime = primes ( i ) if (( prime . gt . a ). and .( prime . gt . b )) return p = prime do while (( modulo ( a , p ) == 0 ). or .( modulo ( b , p ) == 0 )) p = p * prime end do if ( p /= prime ) c = c * p / prime end do ! i end function lcm_ir !*********************************************************************** pure elemental integer ( ik ) function lcm_ik ( a , b ) result ( c ) integer ( ik ), intent ( in ) :: a , b integer ( ir ) :: hold hold = lcm_ir ( int ( a , ir ), int ( b , ir )) if ( hold > huge ( 1_ik )) then error stop \"lcm_ik: overflow\" else c = int ( hold , ik ) end if end function lcm_ik !*********************************************************************** pure elemental integer ( ir ) function gcf_ir ( a , b ) result ( c ) !! Calculate the greatest common factor of two integers integer ( ir ), intent ( in ) :: a , b integer ( ir ) :: i integer ( ir ) :: prime integer ( ir ) :: p if (( a == 0 ) . or . ( b == 0 )) then c = 0 return end if c = 1 do i = 1 , size ( primes ) prime = primes ( i ) if (( prime > abs ( a )). and .( prime > abs ( b ))) return p = prime do while (( modulo ( abs ( a ), p ) == 0 ) . and . ( modulo ( abs ( b ), p ) == 0 )) p = p * prime end do if ( p /= prime ) c = c * p / prime end do ! i end function gcf_ir !*********************************************************************** pure elemental integer ( ik ) function gcf_ik ( a , b ) result ( c ) integer ( ik ), intent ( in ) :: a , b integer ( ir ) :: hold hold = gcf_ir ( int ( a , ir ), int ( b , ir )) if ( hold > huge ( 1_ik )) then error stop \"gcf_ik: overflow\" else c = int ( hold , ik ) end if end function gcf_ik !*********************************************************************** pure elemental type ( rational ) function gcf_rat ( a , b ) result ( c ) !! Calculate the greatest common factor of two rationals type ( rational ), intent ( in ) :: a , b if (( a % num == 0 ). or .( b % num == 0 )) then c = rational ( 0 , 1 ) return end if c % num = gcf ( a % num , b % num ) c % den = lcm_ir ( a % den , b % den ) call c % simplify () end function gcf_rat !*********************************************************************** impure elemental subroutine rat_rand ( a ) !! Retrieve random rational (0.0, order) type ( rational ), intent ( out ) :: a real ( rk ) :: ra call random_number ( ra ) a % num = nint ( ra * order , ik ) a % den = order call a % simplify () end subroutine rat_rand !*********************************************************************** !******************* E N D ********************************************* !*********************************************************************** end module rationals","tags":"","url":"sourcefile/rationals.f90.html"},{"title":"rationals_example.f90 – easy","text":"Source Code program example use rationals implicit none call ex1 () call ex2 () contains subroutine ex1 () integer :: i real ( rk ), parameter :: pi = 4 * atan ( 1.0_rk ) type ( rational ) :: rat_pi write ( * , \"(A)\" ) \"Example: rational representation of pi\" rat_pi = pi write ( * , * ) pi write ( * , * ) rat_pi do i = 1 , 8 write ( * , * ) rational ( int ( pi * 10 ** i ), 10 ** i ) end do ! i write ( * , * ) end subroutine ex1 !*********************************************************************** subroutine ex2 () integer :: i type ( rational ) :: roottwo write ( * , \"(A)\" ) \"Example: approximation of the square root of two\" roottwo = 1 do i = 1 , 10 roottwo = 1 + 1 / ( 1 + roottwo ) write ( * , \"(I3,')',1x,$)\" ) i write ( * , * ) roottwo , real ( roottwo ), real ( roottwo * roottwo ) end do ! i end subroutine ex2 end program example","tags":"","url":"sourcefile/rationals_example.f90.html"},{"title":"rationals_test.f90 – easy","text":"Source Code program rationals_test !! Showcase rationals use iso_fortran_env use rationals implicit none integer ( ir ), parameter :: yoog = huge ( 1_ir ) integer ( ik ) :: ord integer :: unit integer :: stat character ( * ), parameter :: fmt1 = \"(A20,': ',$)\" character ( * ), parameter :: fmt2 = \"('passed')\" character ( 50 ) :: str type ( rational ) :: a , b type ( rational ) :: u ( 2 ), v ( 2 ), m ( 2 , 2 ), n ( 2 , 2 ), p ( 2 , 2 ) str = \"1/2  \" write ( * , \"(A)\" ) \"--- Testing rationals ---\" write ( * , \"(A)\" ) \"Basics\" write ( * , fmt1 ) \"Math\" if ( gcf ( 0 , 2 ) /= 0 ) then error stop \"gcf failed for 0\" end if if ( gcf ( 2 , 3 ) /= 1 ) then error stop \"gcf failed for coprime\" end if if ( gcf ( 12 , 12 ) /= 12 ) then error stop \"gcf failed for equality\" end if if ( gcf ( 3 , 12 ) /= 3 ) then error stop \"gcf failed for result\" end if if ( gcf ( - 3 , 12 ) /= 3 ) then error stop \"gcf failed for negative input\" end if if ( lcm ( 0 , 1 ) /= 0 ) then error stop \"lcm failed for zero\" end if if ( lcm ( 3 , 3 ) /= 3 ) then error stop \"lcm failed for equality\" end if if ( lcm ( 2 , 3 ) /= 6 ) then error stop \"lcm failed for product result\" end if if ( lcm ( 4 , 6 ) /= 12 ) then error stop \"lcm failed for non-product result\" end if if ( lcm ( - 4 , 6 ) /= 12 ) then error stop \"lcm failed for negative\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Constructor\" ! a = rational(1, 1) ! if ((a%get_num() /= 1) .or. (a%get_den() /= 1)) then !   error stop \"Default constructor failed\" ! end if a = rational ( 3 ) if (( a % get_num () /= 3 ) . or . ( a % get_den () /= 1 )) then error stop \"Integer constructor failed\" end if a = rational ( 0.5_rk ) if (( a % get_num () /= 1 ) . or . ( a % get_den () /= 2 )) then error stop \"Real constructor failed\" end if a = rational ( \"1/2\" ) if (( a % get_num () /= 1 ) . or . ( a % get_den () /= 2 )) then error stop \"Character constructor failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"I/O\" read ( str , \"(A)\" , iostat = stat ) a if ( stat /= 0 ) then error stop \"Formatted read failed\" end if open ( newunit = unit , file = \"scratch\" , action = 'write' ) write ( unit , * ) a close ( unit , status = 'delete' ) write ( * , fmt2 ) write ( * , fmt1 ) \"Assignment\" a = 2 if (( a % get_num () /= 2 ) . or . ( a % get_den () /= 1 )) then error stop \"Integer assignment failed\" end if a = 0.5_rk if (( a % get_num () /= 1 ) . or . ( a % get_den () /= 2 )) then error stop \"Real assignment failed\" end if ! a = \"1/2\"   !! Not supported by Fortran b = a if (( b % get_num () /= a % get_num ()) . or . ( b % get_den () /= a % get_den ())) then error stop \"Copying failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Casting\" a = 2 if ( int ( a ) /= 2 ) then error stop \"Casting to integer failed\" end if a = 0.5_rk if ( real ( a ) /= 0.5_rk ) then error stop \"Casting to real failed\" end if if ( char ( a ) /= \"1/2\" ) then error stop \"Casting to character failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"Boolean operators\" write ( * , fmt1 ) \"Equality\" a = 2 b = 2 if (. not .( a == b )) then error stop \"Rational-rational equality failed\" end if if (. not .( a == 2 )) then error stop \"Rational-integer equality failed\" end if if (. not .( 2 == a )) then error stop \"Integer-rational equality failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Inequality\" a = 2 b = 3 if (. not .( a /= b )) then error stop \"Rational-rational inequality failed\" end if if (. not .( a /= 3 )) then error stop \"Rational-integer inequality failed\" end if if (. not .( 3 /= a )) then error stop \"Integer-rational inequality failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Strict superiority\" a = rational ( 3 , 2 ) b = rational ( 2 , 3 ) if (. not .( a > b )) then error stop \"Rational-rational strict superiority failed\" end if if (. not .( a > 1 )) then error stop \"Rational-integer strict superiority failed\" end if if (. not .( 2 > a )) then error stop \"Integer-rational strict superiority failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Strict inferiority\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if (. not .( a < b )) then error stop \"Rational-rational strict inferiority failed\" end if if (. not .( a < 1 )) then error stop \"Rational-integer strict inferiority failed\" end if if (. not .( 0 < a )) then error stop \"Integer-rational strict inferiority failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Superiority\" a = rational ( 3 , 2 ) b = rational ( 2 , 3 ) if (. not .( a >= b )) then error stop \"Rational-rational superiority failed\" end if if (. not .( a >= 1 )) then error stop \"Rational-integer superiority failed\" end if if (. not .( 2 >= a )) then error stop \"Integer-rational superiority failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Inferiority\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if (. not .( a <= b )) then error stop \"Rational-rational inferiority failed\" end if if (. not .( a <= 1 )) then error stop \"Rational-integer inferiority failed\" end if if (. not .( 0 <= a )) then error stop \"Integer-rational inferiority failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"Arithmetic\" write ( * , fmt1 ) \"Addition\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a + b /= rational ( 13 , 6 )) then error stop \"Rational-rational addition failed\" end if if ( a + 1 /= rational ( 5 , 3 )) then error stop \"Rational-integer addition failed\" end if if ( 1 + a /= rational ( 5 , 3 )) then error stop \"Integer-rational addition failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Subtraction\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a - b /= rational ( - 5 , 6 )) then error stop \"Rational-rational subtraction failed\" end if if ( a - 1 /= rational ( - 1 , 3 )) then error stop \"Rational-integer subtraction failed\" end if if ( 1 - a /= rational ( 1 , 3 )) then error stop \"Integer-rational subtraction failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Multiplication\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a * b /= rational ( 1 , 1 )) then error stop \"Rational-rational multiplication failed\" end if if ( a * 2 /= rational ( 4 , 3 )) then error stop \"Rational-integer multiplication failed\" end if if ( 2 * a /= rational ( 4 , 3 )) then error stop \"Integer-rational multiplication failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Division\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( a / b /= rational ( 4 , 9 )) then error stop \"Rational-rational division failed\" end if if ( a / 2 /= rational ( 1 , 3 )) then error stop \"Rational-integer division failed\" end if if ( 2 / a /= rational ( 3 , 1 )) then error stop \"Integer-rational division failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Reciprocal\" a = rational ( 2 , 3 ) if ( a % inverse () /= 1 / a ) then error stop \"Reciprocation failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Exponentiation\" a = rational ( 2 , 3 ) if ( a ** 2 /= rational ( 4 , 9 )) then error stop \"Rational-integer exponentiation failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"Edge cases\" a = rational ( yoog , 2_ir ) b = rational ( 2_ir , yoog ) if ( a * b /= 1 ) then error stop \"Multiplication overflow failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"Functions\" write ( * , fmt1 ) \"abs\" a = rational ( - 1 , 2 ) if ( abs ( a ) /= rational ( 1 , 2 )) then error stop \"Absolute value failed\" end if a = rational ( 1 , 2 ) if ( abs ( a ) /= rational ( 1 , 2 )) then error stop \"Absolute value failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"min\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( min ( a , b ) /= a ) then error stop \"Rational-rational minimum failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"max\" a = rational ( 2 , 3 ) b = rational ( 3 , 2 ) if ( max ( a , b ) /= b ) then error stop \"Rational-rational maximum failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"dot_product\" u = [ rational ( 1 , 2 ), rational ( 2 , 3 )] v = [ rational ( 3 , 4 ), rational ( 4 , 5 )] if ( dot_product ( u , v ) /= rational ( 109 , 120 )) then error stop \"dot_product failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"matmul\" m (:, 1 ) = [ rational ( 1 , 2 ), rational ( 1 , 3 )] m (:, 2 ) = [ rational ( 1 , 1 ), rational ( 2 , 3 )] u = [ rational ( 1 , 4 ), rational ( 3 , 4 )] v = [ rational ( 7 , 8 ), rational ( 7 , 12 )] if (. not . all ( matmul ( m , u ) == v )) then error stop \"matmul for matrix-vector failed\" end if n (:, 1 ) = [ rational ( 1 , 4 ), rational ( 3 , 4 )] n (:, 2 ) = [ rational ( 1 , 2 ), rational ( 1 , 1 )] p (:, 1 ) = [ rational ( 7 , 8 ), rational ( 7 , 12 )] p (:, 2 ) = [ rational ( 5 , 4 ), rational ( 5 , 6 )] if (. not . all ( matmul ( m , n ) == p )) then error stop \"matmul for matrix-matrix failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"transpose\" m (:, 1 ) = [ rational ( 1 , 2 ), rational ( 1 , 3 )] m (:, 2 ) = [ rational ( 1 , 1 ), rational ( 2 , 3 )] n (:, 1 ) = [ rational ( 1 , 2 ), rational ( 1 , 1 )] n (:, 2 ) = [ rational ( 1 , 3 ), rational ( 2 , 3 )] if (. not . all ( transpose ( m ) == n )) then error stop \"transpose failed\" end if write ( * , fmt2 ) write ( * , fmt1 ) \"random_number\" ord = 10 call set_order ( ord ) call random_number ( m ) if ( any ( m < 0 ) . or . any ( m > ord )) then error stop \"random_number failed\" end if write ( * , fmt2 ) write ( * , \"(A)\" ) \"All tests passed\" end program rationals_test","tags":"","url":"sourcefile/rationals_test.f90.html"}]}